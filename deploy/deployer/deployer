#!/usr/bin/env python3

import fnmatch

from cement.core.foundation import CementApp
from cement.ext.ext_argparse import ArgparseController, expose
from fabric import Connection
import uuid
import tarfile
import glob
import os
import time
import sys

from invoke import UnexpectedExit


def okay():
    print("Done.\n")


class ScpDeployController(ArgparseController):

    source = None
    destination = None

    host = None
    user = None
    port = None
    password = None
    temp_dir = None
    exclude_from = None
    no_delete = False

    archive_uuid = None
    timestamp = None
    archive_dir = None
    archive_path = None
    archive_destination_path = None
    project_storage_dir = None
    deployer_lock_path = None
    deployer_temp_lock_path = None
    password_kwargs = None

    exclude_filename_patterns = []

    def default(self):
        self.app.args.print_help()

    @expose(
        arguments=[
            (['source'], {'help': 'Source (on local machine)'}),
            (['destination'], {'help': 'Destination (on remote machine)'}),
            (['--host'], {'help': 'SSH Host'}),
            (['--user', '-u'], {'help': 'SSH User'}),
            (['--port', '-p'], {'help': 'SSH Port', 'default': '22'}),
            (['--password'], {'help': 'SSH Password. SSH Key used by default.'}),
            (['--temp-dir'], {'help': 'The path of the directory used for extracting uploaded files to'}),
            (['--exclude-from'], {'help': 'Path to a text file listing all files and directories to exclude. Use one  '
                                          'Unix shell-style wildcard per line'}),
            (['--no-delete'], {'action': 'store_true', 'help': 'Do not delete the existing destination dir. Rename it '
                                                               'instead by appending a timestamp.'}),
        ],
        help='<Deploy via scp>')
    def deploy(self):

        self.init()

        self.compress_project(self.source, self.archive_path, self.exclude_from)

        connection = self.connect_to_host(self.host, self.user, self.port, self.password_kwargs)

        try:
            connection.run('test -d ' + self.app.pargs.destination)
        except UnexpectedExit:
            print("%s does not exist. Try creating it." % self.app.pargs.destination)
            try:
                connection.run('mkdir -p ' + self.app.pargs.destination)
            except UnexpectedExit:
                print("Not able to create %s" % self.app.pargs.destination)
                app.close(code=1)
                sys.exit(1)
            okay()
        print("Trying to allocate lock")
        try:
            connection.run('test -f ' + self.app.pargs.destination + '/deployer.lock')
            self.app.log.error(
                "%s already exists. There might be another instance of deployer running." % self.deployer_lock_path)
            app.close(code=1)
            sys.exit(1)

        except UnexpectedExit:
            connection.run('touch ' + self.deployer_lock_path)
            print("Created %s" % self.deployer_lock_path)
            okay()

        try:
            print("Uploading %s to %s@%s:%s:%s..." % (
                self.archive_path, self.user, self.host, self.port, self.archive_destination_path))
            connection.put(self.archive_path, remote=self.archive_destination_path)
            okay()
            print("Creating temp dir %s" % self.temp_dir)
            connection.run('mkdir -p ' + self.temp_dir)
            okay()
            print("Untar uploaded archive %s to %s" % (self.archive_destination_path, self.temp_dir))
            connection.run('tar xfv ' + self.archive_destination_path + ' -C ' + self.temp_dir)
            okay()
            print("Trying to allocate lock in %s" % self.deployer_temp_lock_path)
            connection.run('touch ' + self.deployer_temp_lock_path)
            okay()
            print("Deleting uploaded archive %s" % self.archive_destination_path)
            connection.run('rm ' + self.archive_destination_path)
            okay()
            print("Renaming %s to %s" % (self.destination, self.project_storage_dir))
            connection.run('mv ' + self.destination + ' ' + self.project_storage_dir)
            okay()
            print("Renaming %s to %s" % (self.temp_dir, self.destination))
            connection.run('mv ' + self.temp_dir + ' ' + self.destination)
            okay()
            if not self.no_delete:
                print("Deleting old project in directory %s" % self.project_storage_dir)
                connection.run('rm -rf ' + self.project_storage_dir)
                okay()
            print("Deployment successful! \n")
        finally:
            print("Freeing lock %s" % self.deployer_lock_path)
            connection.run('rm ' + self.deployer_lock_path)
            okay()
            print("Removing local archive %s" % self.archive_dir)
            os.remove(self.archive_path)
            os.rmdir(self.archive_dir)
            okay()

    def init(self):
        # assign cli params to object names for convenience
        self.temp_dir = self.app.pargs.temp_dir
        self.host = self.app.pargs.host
        self.user = self.app.pargs.user
        self.port = self.app.pargs.port
        self.password = self.app.pargs.password
        self.exclude_from = self.app.pargs.exclude_from
        self.no_delete = self.app.pargs.no_delete

        self.source = self.app.pargs.source
        self.destination = self.app.pargs.destination

        if self.host is None or self.user is None:
            self.app.log.error('You have to provide HOST and USER')
            app.close(code=1)
            sys.exit(1)

        if self.temp_dir is None:
            self.temp_dir = self.destination + '_deployer_temp'

        if self.password is not None:
            self.password_kwargs = {"password": self.app.pargs.password}

        self.archive_uuid = str(uuid.uuid4())
        self.timestamp = str(int(time.time()))
        self.archive_dir = '/tmp/deployer/' + self.archive_uuid
        self.archive_path = self.archive_dir + '/deployer_project.tar'
        self.archive_destination_path = self.destination + '/deployer_' + self.archive_uuid + '.tar'
        self.project_storage_dir = self.destination + '_old_' + self.timestamp
        self.deployer_lock_path = self.destination + '/deployer.lock'
        self.deployer_temp_lock_path = self.temp_dir + '/deployer.lock'

    def compress_project(self, source, archive_path, exclude_from):
        print("Parsing %s to exclude files from deployment" % exclude_from)
        if exclude_from is not None:
            with open(exclude_from, "r") as file:
                self.exclude_filename_patterns = [line.rstrip('\n') for line in file]
                for line in self.exclude_filename_patterns:
                    print("   %s" % line)
            okay()

        print("Compressing files to %s..." % archive_path)
        os.makedirs(os.path.split(archive_path)[0])
        tar = tarfile.open(archive_path, "w:gz")
        for file_name in glob.glob(os.path.join(source, "*")):
            tar.add(name=file_name, arcname=os.path.basename(file_name), exclude=self.is_file_excluded)
        tar.close()
        okay()

    def connect_to_host(self, host, user, port, kwargs):
        print("Trying to connect to %s@%s:%s" % (user, host, port))
        connection = Connection(host=host, user=user, port=port,
                                connect_kwargs=kwargs)
        connection.open()
        if connection.is_connected:
            okay()
            return connection
        else:
            self.app.log.error('Failed to connect.')
            app.close(code=1)
            sys.exit(1)

    def is_file_excluded(self, file_name):
        if any(fnmatch.fnmatch(file_name, pattern) for pattern in self.exclude_filename_patterns):
            print("  Excluding %s" % file_name)
            return True
        else:
            print("  Adding %s" % file_name)
            return False


class MyApp(CementApp):
    class Meta:
        label = 'deployer'
        handlers = [ScpDeployController]


with MyApp() as app:
    app.run()
